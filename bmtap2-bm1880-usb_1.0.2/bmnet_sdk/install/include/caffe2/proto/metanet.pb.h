// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/metanet.proto

#ifndef PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED
#define PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)

namespace caffe2 {

// Internal implementation detail -- do not call these.
void CAFFE2_API protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

class ModelInfo;
class BlobsMap;
class NetsMap;
class PlansMap;
class StringMap;
class MetaNetDef;

// ===================================================================

class CAFFE2_API ModelInfo : public ::google::protobuf::Message {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo& default_instance();

  void Swap(ModelInfo* other);

  // implements Message ----------------------------------------------

  ModelInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string project = 1;
  inline bool has_project() const;
  inline void clear_project();
  static const int kProjectFieldNumber = 1;
  inline const ::std::string& project() const;
  inline void set_project(const ::std::string& value);
  inline void set_project(const char* value);
  inline void set_project(const char* value, size_t size);
  inline ::std::string* mutable_project();
  inline ::std::string* release_project();
  inline void set_allocated_project(::std::string* project);

  // optional string modelClass = 2;
  inline bool has_modelclass() const;
  inline void clear_modelclass();
  static const int kModelClassFieldNumber = 2;
  inline const ::std::string& modelclass() const;
  inline void set_modelclass(const ::std::string& value);
  inline void set_modelclass(const char* value);
  inline void set_modelclass(const char* value, size_t size);
  inline ::std::string* mutable_modelclass();
  inline ::std::string* release_modelclass();
  inline void set_allocated_modelclass(::std::string* modelclass);

  // optional string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
  inline bool has_predictortype() const;
  inline void clear_predictortype();
  static const int kPredictorTypeFieldNumber = 4;
  inline const ::std::string& predictortype() const;
  inline void set_predictortype(const ::std::string& value);
  inline void set_predictortype(const char* value);
  inline void set_predictortype(const char* value, size_t size);
  inline ::std::string* mutable_predictortype();
  inline ::std::string* release_predictortype();
  inline void set_allocated_predictortype(::std::string* predictortype);

  // optional string modelId = 5;
  inline bool has_modelid() const;
  inline void clear_modelid();
  static const int kModelIdFieldNumber = 5;
  inline const ::std::string& modelid() const;
  inline void set_modelid(const ::std::string& value);
  inline void set_modelid(const char* value);
  inline void set_modelid(const char* value, size_t size);
  inline ::std::string* mutable_modelid();
  inline ::std::string* release_modelid();
  inline void set_allocated_modelid(::std::string* modelid);

  // @@protoc_insertion_point(class_scope:caffe2.ModelInfo)
 private:
  inline void set_has_project();
  inline void clear_has_project();
  inline void set_has_modelclass();
  inline void clear_has_modelclass();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_predictortype();
  inline void clear_has_predictortype();
  inline void set_has_modelid();
  inline void clear_has_modelid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* project_;
  ::std::string* modelclass_;
  ::std::string* version_;
  static ::std::string* _default_predictortype_;
  ::std::string* predictortype_;
  ::std::string* modelid_;
  friend void CAFFE2_API protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
  static ModelInfo* default_instance_;
};
// -------------------------------------------------------------------

class CAFFE2_API BlobsMap : public ::google::protobuf::Message {
 public:
  BlobsMap();
  virtual ~BlobsMap();

  BlobsMap(const BlobsMap& from);

  inline BlobsMap& operator=(const BlobsMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlobsMap& default_instance();

  void Swap(BlobsMap* other);

  // implements Message ----------------------------------------------

  BlobsMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlobsMap& from);
  void MergeFrom(const BlobsMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // repeated string value = 2;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value(int index) const;
  inline ::std::string* mutable_value(int index);
  inline void set_value(int index, const ::std::string& value);
  inline void set_value(int index, const char* value);
  inline void set_value(int index, const char* value, size_t size);
  inline ::std::string* add_value();
  inline void add_value(const ::std::string& value);
  inline void add_value(const char* value);
  inline void add_value(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& value() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value();

  // @@protoc_insertion_point(class_scope:caffe2.BlobsMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_;
  friend void CAFFE2_API protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
  static BlobsMap* default_instance_;
};
// -------------------------------------------------------------------

class CAFFE2_API NetsMap : public ::google::protobuf::Message {
 public:
  NetsMap();
  virtual ~NetsMap();

  NetsMap(const NetsMap& from);

  inline NetsMap& operator=(const NetsMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetsMap& default_instance();

  void Swap(NetsMap* other);

  // implements Message ----------------------------------------------

  NetsMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetsMap& from);
  void MergeFrom(const NetsMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required .caffe2.NetDef value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::caffe2::NetDef& value() const;
  inline ::caffe2::NetDef* mutable_value();
  inline ::caffe2::NetDef* release_value();
  inline void set_allocated_value(::caffe2::NetDef* value);

  // @@protoc_insertion_point(class_scope:caffe2.NetsMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::caffe2::NetDef* value_;
  friend void CAFFE2_API protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
  static NetsMap* default_instance_;
};
// -------------------------------------------------------------------

class CAFFE2_API PlansMap : public ::google::protobuf::Message {
 public:
  PlansMap();
  virtual ~PlansMap();

  PlansMap(const PlansMap& from);

  inline PlansMap& operator=(const PlansMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlansMap& default_instance();

  void Swap(PlansMap* other);

  // implements Message ----------------------------------------------

  PlansMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlansMap& from);
  void MergeFrom(const PlansMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required .caffe2.PlanDef value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::caffe2::PlanDef& value() const;
  inline ::caffe2::PlanDef* mutable_value();
  inline ::caffe2::PlanDef* release_value();
  inline void set_allocated_value(::caffe2::PlanDef* value);

  // @@protoc_insertion_point(class_scope:caffe2.PlansMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::caffe2::PlanDef* value_;
  friend void CAFFE2_API protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
  static PlansMap* default_instance_;
};
// -------------------------------------------------------------------

class CAFFE2_API StringMap : public ::google::protobuf::Message {
 public:
  StringMap();
  virtual ~StringMap();

  StringMap(const StringMap& from);

  inline StringMap& operator=(const StringMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringMap& default_instance();

  void Swap(StringMap* other);

  // implements Message ----------------------------------------------

  StringMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StringMap& from);
  void MergeFrom(const StringMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:caffe2.StringMap)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void CAFFE2_API protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
  static StringMap* default_instance_;
};
// -------------------------------------------------------------------

class CAFFE2_API MetaNetDef : public ::google::protobuf::Message {
 public:
  MetaNetDef();
  virtual ~MetaNetDef();

  MetaNetDef(const MetaNetDef& from);

  inline MetaNetDef& operator=(const MetaNetDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaNetDef& default_instance();

  void Swap(MetaNetDef* other);

  // implements Message ----------------------------------------------

  MetaNetDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaNetDef& from);
  void MergeFrom(const MetaNetDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .caffe2.BlobsMap blobs = 1;
  inline int blobs_size() const;
  inline void clear_blobs();
  static const int kBlobsFieldNumber = 1;
  inline const ::caffe2::BlobsMap& blobs(int index) const;
  inline ::caffe2::BlobsMap* mutable_blobs(int index);
  inline ::caffe2::BlobsMap* add_blobs();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >&
      blobs() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >*
      mutable_blobs();

  // repeated .caffe2.NetsMap nets = 2;
  inline int nets_size() const;
  inline void clear_nets();
  static const int kNetsFieldNumber = 2;
  inline const ::caffe2::NetsMap& nets(int index) const;
  inline ::caffe2::NetsMap* mutable_nets(int index);
  inline ::caffe2::NetsMap* add_nets();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >&
      nets() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >*
      mutable_nets();

  // optional .caffe2.ModelInfo modelInfo = 3;
  inline bool has_modelinfo() const;
  inline void clear_modelinfo();
  static const int kModelInfoFieldNumber = 3;
  inline const ::caffe2::ModelInfo& modelinfo() const;
  inline ::caffe2::ModelInfo* mutable_modelinfo();
  inline ::caffe2::ModelInfo* release_modelinfo();
  inline void set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo);

  // repeated .caffe2.PlansMap plans = 4;
  inline int plans_size() const;
  inline void clear_plans();
  static const int kPlansFieldNumber = 4;
  inline const ::caffe2::PlansMap& plans(int index) const;
  inline ::caffe2::PlansMap* mutable_plans(int index);
  inline ::caffe2::PlansMap* add_plans();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >&
      plans() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >*
      mutable_plans();

  // repeated .caffe2.StringMap applicationSpecificInfo = 5;
  inline int applicationspecificinfo_size() const;
  inline void clear_applicationspecificinfo();
  static const int kApplicationSpecificInfoFieldNumber = 5;
  inline const ::caffe2::StringMap& applicationspecificinfo(int index) const;
  inline ::caffe2::StringMap* mutable_applicationspecificinfo(int index);
  inline ::caffe2::StringMap* add_applicationspecificinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >&
      applicationspecificinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >*
      mutable_applicationspecificinfo();

  // @@protoc_insertion_point(class_scope:caffe2.MetaNetDef)
 private:
  inline void set_has_modelinfo();
  inline void clear_has_modelinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap > blobs_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap > nets_;
  ::caffe2::ModelInfo* modelinfo_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap > plans_;
  ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap > applicationspecificinfo_;
  friend void CAFFE2_API protobuf_AddDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_AssignDesc_caffe2_2fproto_2fmetanet_2eproto();
  friend void protobuf_ShutdownFile_caffe2_2fproto_2fmetanet_2eproto();

  void InitAsDefaultInstance();
  static MetaNetDef* default_instance_;
};
// ===================================================================


// ===================================================================

// ModelInfo

// optional string project = 1;
inline bool ModelInfo::has_project() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo::set_has_project() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelInfo::clear_has_project() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelInfo::clear_project() {
  if (project_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    project_->clear();
  }
  clear_has_project();
}
inline const ::std::string& ModelInfo::project() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.project)
  return *project_;
}
inline void ModelInfo::set_project(const ::std::string& value) {
  set_has_project();
  if (project_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    project_ = new ::std::string;
  }
  project_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value) {
  set_has_project();
  if (project_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    project_ = new ::std::string;
  }
  project_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value, size_t size) {
  set_has_project();
  if (project_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    project_ = new ::std::string;
  }
  project_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.project)
}
inline ::std::string* ModelInfo::mutable_project() {
  set_has_project();
  if (project_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    project_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.project)
  return project_;
}
inline ::std::string* ModelInfo::release_project() {
  clear_has_project();
  if (project_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = project_;
    project_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModelInfo::set_allocated_project(::std::string* project) {
  if (project_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete project_;
  }
  if (project) {
    set_has_project();
    project_ = project;
  } else {
    clear_has_project();
    project_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.project)
}

// optional string modelClass = 2;
inline bool ModelInfo::has_modelclass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo::set_has_modelclass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelInfo::clear_has_modelclass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelInfo::clear_modelclass() {
  if (modelclass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelclass_->clear();
  }
  clear_has_modelclass();
}
inline const ::std::string& ModelInfo::modelclass() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelClass)
  return *modelclass_;
}
inline void ModelInfo::set_modelclass(const ::std::string& value) {
  set_has_modelclass();
  if (modelclass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelclass_ = new ::std::string;
  }
  modelclass_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelClass)
}
inline void ModelInfo::set_modelclass(const char* value) {
  set_has_modelclass();
  if (modelclass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelclass_ = new ::std::string;
  }
  modelclass_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelClass)
}
inline void ModelInfo::set_modelclass(const char* value, size_t size) {
  set_has_modelclass();
  if (modelclass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelclass_ = new ::std::string;
  }
  modelclass_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelClass)
}
inline ::std::string* ModelInfo::mutable_modelclass() {
  set_has_modelclass();
  if (modelclass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelclass_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelClass)
  return modelclass_;
}
inline ::std::string* ModelInfo::release_modelclass() {
  clear_has_modelclass();
  if (modelclass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelclass_;
    modelclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModelInfo::set_allocated_modelclass(::std::string* modelclass) {
  if (modelclass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelclass_;
  }
  if (modelclass) {
    set_has_modelclass();
    modelclass_ = modelclass;
  } else {
    clear_has_modelclass();
    modelclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelClass)
}

// optional string version = 3;
inline bool ModelInfo::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelInfo::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.version)
  return *version_;
}
inline void ModelInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.version)
}
inline ::std::string* ModelInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.version)
  return version_;
}
inline ::std::string* ModelInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModelInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.version)
}

// optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
inline bool ModelInfo::has_predictortype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModelInfo::set_has_predictortype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModelInfo::clear_has_predictortype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModelInfo::clear_predictortype() {
  if (predictortype_ != _default_predictortype_) {
    predictortype_->assign(*_default_predictortype_);
  }
  clear_has_predictortype();
}
inline const ::std::string& ModelInfo::predictortype() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.predictorType)
  return *predictortype_;
}
inline void ModelInfo::set_predictortype(const ::std::string& value) {
  set_has_predictortype();
  if (predictortype_ == _default_predictortype_) {
    predictortype_ = new ::std::string;
  }
  predictortype_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.predictorType)
}
inline void ModelInfo::set_predictortype(const char* value) {
  set_has_predictortype();
  if (predictortype_ == _default_predictortype_) {
    predictortype_ = new ::std::string;
  }
  predictortype_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.predictorType)
}
inline void ModelInfo::set_predictortype(const char* value, size_t size) {
  set_has_predictortype();
  if (predictortype_ == _default_predictortype_) {
    predictortype_ = new ::std::string;
  }
  predictortype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.predictorType)
}
inline ::std::string* ModelInfo::mutable_predictortype() {
  set_has_predictortype();
  if (predictortype_ == _default_predictortype_) {
    predictortype_ = new ::std::string(*_default_predictortype_);
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.predictorType)
  return predictortype_;
}
inline ::std::string* ModelInfo::release_predictortype() {
  clear_has_predictortype();
  if (predictortype_ == _default_predictortype_) {
    return NULL;
  } else {
    ::std::string* temp = predictortype_;
    predictortype_ = const_cast< ::std::string*>(_default_predictortype_);
    return temp;
  }
}
inline void ModelInfo::set_allocated_predictortype(::std::string* predictortype) {
  if (predictortype_ != _default_predictortype_) {
    delete predictortype_;
  }
  if (predictortype) {
    set_has_predictortype();
    predictortype_ = predictortype;
  } else {
    clear_has_predictortype();
    predictortype_ = const_cast< ::std::string*>(_default_predictortype_);
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.predictorType)
}

// optional string modelId = 5;
inline bool ModelInfo::has_modelid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModelInfo::set_has_modelid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModelInfo::clear_has_modelid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModelInfo::clear_modelid() {
  if (modelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_->clear();
  }
  clear_has_modelid();
}
inline const ::std::string& ModelInfo::modelid() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelId)
  return *modelid_;
}
inline void ModelInfo::set_modelid(const ::std::string& value) {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  modelid_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelId)
}
inline void ModelInfo::set_modelid(const char* value) {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  modelid_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelId)
}
inline void ModelInfo::set_modelid(const char* value, size_t size) {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  modelid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelId)
}
inline ::std::string* ModelInfo::mutable_modelid() {
  set_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelId)
  return modelid_;
}
inline ::std::string* ModelInfo::release_modelid() {
  clear_has_modelid();
  if (modelid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelid_;
    modelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ModelInfo::set_allocated_modelid(::std::string* modelid) {
  if (modelid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelid_;
  }
  if (modelid) {
    set_has_modelid();
    modelid_ = modelid;
  } else {
    clear_has_modelid();
    modelid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelId)
}

// -------------------------------------------------------------------

// BlobsMap

// required string key = 1;
inline bool BlobsMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlobsMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlobsMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlobsMap::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& BlobsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.key)
  return *key_;
}
inline void BlobsMap::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.key)
}
inline void BlobsMap::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.key)
}
inline void BlobsMap::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.key)
}
inline ::std::string* BlobsMap::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.key)
  return key_;
}
inline ::std::string* BlobsMap::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void BlobsMap::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobsMap.key)
}

// repeated string value = 2;
inline int BlobsMap::value_size() const {
  return value_.size();
}
inline void BlobsMap::clear_value() {
  value_.Clear();
}
inline const ::std::string& BlobsMap::value(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.value)
  return value_.Get(index);
}
inline ::std::string* BlobsMap::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.value)
  return value_.Mutable(index);
}
inline void BlobsMap::set_value(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.value)
  value_.Mutable(index)->assign(value);
}
inline void BlobsMap::set_value(int index, const char* value) {
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.value)
}
inline ::std::string* BlobsMap::add_value() {
  return value_.Add();
}
inline void BlobsMap::add_value(const ::std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(const char* value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.BlobsMap.value)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BlobsMap::value() const {
  // @@protoc_insertion_point(field_list:caffe2.BlobsMap.value)
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BlobsMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.BlobsMap.value)
  return &value_;
}

// -------------------------------------------------------------------

// NetsMap

// required string key = 1;
inline bool NetsMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetsMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetsMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetsMap::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& NetsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.key)
  return *key_;
}
inline void NetsMap::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.NetsMap.key)
}
inline void NetsMap::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.NetsMap.key)
}
inline void NetsMap::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetsMap.key)
}
inline ::std::string* NetsMap::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.key)
  return key_;
}
inline ::std::string* NetsMap::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NetsMap::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.key)
}

// required .caffe2.NetDef value = 2;
inline bool NetsMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetsMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetsMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetsMap::clear_value() {
  if (value_ != NULL) value_->::caffe2::NetDef::Clear();
  clear_has_value();
}
inline const ::caffe2::NetDef& NetsMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::caffe2::NetDef* NetsMap::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::caffe2::NetDef;
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.value)
  return value_;
}
inline ::caffe2::NetDef* NetsMap::release_value() {
  clear_has_value();
  ::caffe2::NetDef* temp = value_;
  value_ = NULL;
  return temp;
}
inline void NetsMap::set_allocated_value(::caffe2::NetDef* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.value)
}

// -------------------------------------------------------------------

// PlansMap

// required string key = 1;
inline bool PlansMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlansMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlansMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlansMap::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& PlansMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.key)
  return *key_;
}
inline void PlansMap::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.PlansMap.key)
}
inline void PlansMap::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.PlansMap.key)
}
inline void PlansMap::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.PlansMap.key)
}
inline ::std::string* PlansMap::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.key)
  return key_;
}
inline ::std::string* PlansMap::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PlansMap::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.key)
}

// required .caffe2.PlanDef value = 2;
inline bool PlansMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlansMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlansMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlansMap::clear_value() {
  if (value_ != NULL) value_->::caffe2::PlanDef::Clear();
  clear_has_value();
}
inline const ::caffe2::PlanDef& PlansMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::caffe2::PlanDef* PlansMap::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::caffe2::PlanDef;
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.value)
  return value_;
}
inline ::caffe2::PlanDef* PlansMap::release_value() {
  clear_has_value();
  ::caffe2::PlanDef* temp = value_;
  value_ = NULL;
  return temp;
}
inline void PlansMap::set_allocated_value(::caffe2::PlanDef* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.value)
}

// -------------------------------------------------------------------

// StringMap

// required string key = 1;
inline bool StringMap::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringMap::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringMap::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringMap::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& StringMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.key)
  return *key_;
}
inline void StringMap::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.key)
}
inline void StringMap::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.key)
}
inline void StringMap::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.key)
}
inline ::std::string* StringMap::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.key)
  return key_;
}
inline ::std::string* StringMap::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StringMap::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.key)
}

// required string value = 2;
inline bool StringMap::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringMap::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringMap::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringMap::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& StringMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.value)
  return *value_;
}
inline void StringMap::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.value)
}
inline void StringMap::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.value)
}
inline void StringMap::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.value)
}
inline ::std::string* StringMap::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.value)
  return value_;
}
inline ::std::string* StringMap::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StringMap::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.value)
}

// -------------------------------------------------------------------

// MetaNetDef

// repeated .caffe2.BlobsMap blobs = 1;
inline int MetaNetDef::blobs_size() const {
  return blobs_.size();
}
inline void MetaNetDef::clear_blobs() {
  blobs_.Clear();
}
inline const ::caffe2::BlobsMap& MetaNetDef::blobs(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.blobs)
  return blobs_.Get(index);
}
inline ::caffe2::BlobsMap* MetaNetDef::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.blobs)
  return blobs_.Mutable(index);
}
inline ::caffe2::BlobsMap* MetaNetDef::add_blobs() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.blobs)
  return blobs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >&
MetaNetDef::blobs() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.blobs)
  return blobs_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::BlobsMap >*
MetaNetDef::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.blobs)
  return &blobs_;
}

// repeated .caffe2.NetsMap nets = 2;
inline int MetaNetDef::nets_size() const {
  return nets_.size();
}
inline void MetaNetDef::clear_nets() {
  nets_.Clear();
}
inline const ::caffe2::NetsMap& MetaNetDef::nets(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.nets)
  return nets_.Get(index);
}
inline ::caffe2::NetsMap* MetaNetDef::mutable_nets(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.nets)
  return nets_.Mutable(index);
}
inline ::caffe2::NetsMap* MetaNetDef::add_nets() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.nets)
  return nets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >&
MetaNetDef::nets() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.nets)
  return nets_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::NetsMap >*
MetaNetDef::mutable_nets() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.nets)
  return &nets_;
}

// optional .caffe2.ModelInfo modelInfo = 3;
inline bool MetaNetDef::has_modelinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaNetDef::set_has_modelinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MetaNetDef::clear_has_modelinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MetaNetDef::clear_modelinfo() {
  if (modelinfo_ != NULL) modelinfo_->::caffe2::ModelInfo::Clear();
  clear_has_modelinfo();
}
inline const ::caffe2::ModelInfo& MetaNetDef::modelinfo() const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.modelInfo)
  return modelinfo_ != NULL ? *modelinfo_ : *default_instance_->modelinfo_;
}
inline ::caffe2::ModelInfo* MetaNetDef::mutable_modelinfo() {
  set_has_modelinfo();
  if (modelinfo_ == NULL) modelinfo_ = new ::caffe2::ModelInfo;
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.modelInfo)
  return modelinfo_;
}
inline ::caffe2::ModelInfo* MetaNetDef::release_modelinfo() {
  clear_has_modelinfo();
  ::caffe2::ModelInfo* temp = modelinfo_;
  modelinfo_ = NULL;
  return temp;
}
inline void MetaNetDef::set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo) {
  delete modelinfo_;
  modelinfo_ = modelinfo;
  if (modelinfo) {
    set_has_modelinfo();
  } else {
    clear_has_modelinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:caffe2.MetaNetDef.modelInfo)
}

// repeated .caffe2.PlansMap plans = 4;
inline int MetaNetDef::plans_size() const {
  return plans_.size();
}
inline void MetaNetDef::clear_plans() {
  plans_.Clear();
}
inline const ::caffe2::PlansMap& MetaNetDef::plans(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.plans)
  return plans_.Get(index);
}
inline ::caffe2::PlansMap* MetaNetDef::mutable_plans(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.plans)
  return plans_.Mutable(index);
}
inline ::caffe2::PlansMap* MetaNetDef::add_plans() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.plans)
  return plans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >&
MetaNetDef::plans() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.plans)
  return plans_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::PlansMap >*
MetaNetDef::mutable_plans() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.plans)
  return &plans_;
}

// repeated .caffe2.StringMap applicationSpecificInfo = 5;
inline int MetaNetDef::applicationspecificinfo_size() const {
  return applicationspecificinfo_.size();
}
inline void MetaNetDef::clear_applicationspecificinfo() {
  applicationspecificinfo_.Clear();
}
inline const ::caffe2::StringMap& MetaNetDef::applicationspecificinfo(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Get(index);
}
inline ::caffe2::StringMap* MetaNetDef::mutable_applicationspecificinfo(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Mutable(index);
}
inline ::caffe2::StringMap* MetaNetDef::add_applicationspecificinfo() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >&
MetaNetDef::applicationspecificinfo() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::caffe2::StringMap >*
MetaNetDef::mutable_applicationspecificinfo() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return &applicationspecificinfo_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_caffe2_2fproto_2fmetanet_2eproto__INCLUDED
