// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bmodel.proto

#ifndef PROTOBUF_bmodel_2eproto__INCLUDED
#define PROTOBUF_bmodel_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace bmodel {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_bmodel_2eproto();
void protobuf_AssignDesc_bmodel_2eproto();
void protobuf_ShutdownFile_bmodel_2eproto();

class Shape;
class Output;
class Input;
class Command;
class Library;
class Model;

// ===================================================================

class Shape : public ::google::protobuf::Message {
 public:
  Shape();
  virtual ~Shape();

  Shape(const Shape& from);

  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shape& default_instance();

  void Swap(Shape* other);

  // implements Message ----------------------------------------------

  Shape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Shape& from);
  void MergeFrom(const Shape& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 dim = 1 [packed = true];
  inline int dim_size() const;
  inline void clear_dim();
  static const int kDimFieldNumber = 1;
  inline ::google::protobuf::uint32 dim(int index) const;
  inline void set_dim(int index, ::google::protobuf::uint32 value);
  inline void add_dim(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dim() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dim();

  // @@protoc_insertion_point(class_scope:bmodel.Shape)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dim_;
  mutable int _dim_cached_byte_size_;
  friend void  protobuf_AddDesc_bmodel_2eproto();
  friend void protobuf_AssignDesc_bmodel_2eproto();
  friend void protobuf_ShutdownFile_bmodel_2eproto();

  void InitAsDefaultInstance();
  static Shape* default_instance_;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  void Swap(Output* other);

  // implements Message ----------------------------------------------

  Output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .bmodel.Shape shape = 2;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 2;
  inline const ::bmodel::Shape& shape() const;
  inline ::bmodel::Shape* mutable_shape();
  inline ::bmodel::Shape* release_shape();
  inline void set_allocated_shape(::bmodel::Shape* shape);

  // required uint64 offset = 3;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 3;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);

  // optional float threshold = 4 [default = 0];
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 4;
  inline float threshold() const;
  inline void set_threshold(float value);

  // @@protoc_insertion_point(class_scope:bmodel.Output)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_threshold();
  inline void clear_has_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::bmodel::Shape* shape_;
  ::google::protobuf::uint64 offset_;
  float threshold_;
  friend void  protobuf_AddDesc_bmodel_2eproto();
  friend void protobuf_AssignDesc_bmodel_2eproto();
  friend void protobuf_ShutdownFile_bmodel_2eproto();

  void InitAsDefaultInstance();
  static Output* default_instance_;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  void Swap(Input* other);

  // implements Message ----------------------------------------------

  Input* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .bmodel.Shape shape = 1;
  inline bool has_shape() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 1;
  inline const ::bmodel::Shape& shape() const;
  inline ::bmodel::Shape* mutable_shape();
  inline ::bmodel::Shape* release_shape();
  inline void set_allocated_shape(::bmodel::Shape* shape);

  // optional float threshold = 2 [default = 0];
  inline bool has_threshold() const;
  inline void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  inline float threshold() const;
  inline void set_threshold(float value);

  // @@protoc_insertion_point(class_scope:bmodel.Input)
 private:
  inline void set_has_shape();
  inline void clear_has_shape();
  inline void set_has_threshold();
  inline void clear_has_threshold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::bmodel::Shape* shape_;
  float threshold_;
  friend void  protobuf_AddDesc_bmodel_2eproto();
  friend void protobuf_AssignDesc_bmodel_2eproto();
  friend void protobuf_ShutdownFile_bmodel_2eproto();

  void InitAsDefaultInstance();
  static Input* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bmodel.Input input = 1;
  inline int input_size() const;
  inline void clear_input();
  static const int kInputFieldNumber = 1;
  inline const ::bmodel::Input& input(int index) const;
  inline ::bmodel::Input* mutable_input(int index);
  inline ::bmodel::Input* add_input();
  inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Input >&
      input() const;
  inline ::google::protobuf::RepeatedPtrField< ::bmodel::Input >*
      mutable_input();

  // required bytes cmdbuf = 2;
  inline bool has_cmdbuf() const;
  inline void clear_cmdbuf();
  static const int kCmdbufFieldNumber = 2;
  inline const ::std::string& cmdbuf() const;
  inline void set_cmdbuf(const ::std::string& value);
  inline void set_cmdbuf(const char* value);
  inline void set_cmdbuf(const void* value, size_t size);
  inline ::std::string* mutable_cmdbuf();
  inline ::std::string* release_cmdbuf();
  inline void set_allocated_cmdbuf(::std::string* cmdbuf);

  // required uint64 neuron_size = 3;
  inline bool has_neuron_size() const;
  inline void clear_neuron_size();
  static const int kNeuronSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 neuron_size() const;
  inline void set_neuron_size(::google::protobuf::uint64 value);

  // repeated .bmodel.Output output = 4;
  inline int output_size() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 4;
  inline const ::bmodel::Output& output(int index) const;
  inline ::bmodel::Output* mutable_output(int index);
  inline ::bmodel::Output* add_output();
  inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Output >&
      output() const;
  inline ::google::protobuf::RepeatedPtrField< ::bmodel::Output >*
      mutable_output();

  // optional uint32 weight_index = 5 [default = 0];
  inline bool has_weight_index() const;
  inline void clear_weight_index();
  static const int kWeightIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 weight_index() const;
  inline void set_weight_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bmodel.Command)
 private:
  inline void set_has_cmdbuf();
  inline void clear_has_cmdbuf();
  inline void set_has_neuron_size();
  inline void clear_has_neuron_size();
  inline void set_has_weight_index();
  inline void clear_has_weight_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Input > input_;
  ::std::string* cmdbuf_;
  ::google::protobuf::uint64 neuron_size_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Output > output_;
  ::google::protobuf::uint32 weight_index_;
  friend void  protobuf_AddDesc_bmodel_2eproto();
  friend void protobuf_AssignDesc_bmodel_2eproto();
  friend void protobuf_ShutdownFile_bmodel_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Library : public ::google::protobuf::Message {
 public:
  Library();
  virtual ~Library();

  Library(const Library& from);

  inline Library& operator=(const Library& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Library& default_instance();

  void Swap(Library* other);

  // implements Message ----------------------------------------------

  Library* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Library& from);
  void MergeFrom(const Library& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required bytes lib_x86_64 = 2;
  inline bool has_lib_x86_64() const;
  inline void clear_lib_x86_64();
  static const int kLibX8664FieldNumber = 2;
  inline const ::std::string& lib_x86_64() const;
  inline void set_lib_x86_64(const ::std::string& value);
  inline void set_lib_x86_64(const char* value);
  inline void set_lib_x86_64(const void* value, size_t size);
  inline ::std::string* mutable_lib_x86_64();
  inline ::std::string* release_lib_x86_64();
  inline void set_allocated_lib_x86_64(::std::string* lib_x86_64);

  // required bytes lib_armv8 = 3;
  inline bool has_lib_armv8() const;
  inline void clear_lib_armv8();
  static const int kLibArmv8FieldNumber = 3;
  inline const ::std::string& lib_armv8() const;
  inline void set_lib_armv8(const ::std::string& value);
  inline void set_lib_armv8(const char* value);
  inline void set_lib_armv8(const void* value, size_t size);
  inline ::std::string* mutable_lib_armv8();
  inline ::std::string* release_lib_armv8();
  inline void set_allocated_lib_armv8(::std::string* lib_armv8);

  // @@protoc_insertion_point(class_scope:bmodel.Library)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_lib_x86_64();
  inline void clear_has_lib_x86_64();
  inline void set_has_lib_armv8();
  inline void clear_has_lib_armv8();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* lib_x86_64_;
  ::std::string* lib_armv8_;
  friend void  protobuf_AddDesc_bmodel_2eproto();
  friend void protobuf_AssignDesc_bmodel_2eproto();
  friend void protobuf_ShutdownFile_bmodel_2eproto();

  void InitAsDefaultInstance();
  static Library* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  void Swap(Model* other);

  // implements Message ----------------------------------------------

  Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string net_name = 1;
  inline bool has_net_name() const;
  inline void clear_net_name();
  static const int kNetNameFieldNumber = 1;
  inline const ::std::string& net_name() const;
  inline void set_net_name(const ::std::string& value);
  inline void set_net_name(const char* value);
  inline void set_net_name(const char* value, size_t size);
  inline ::std::string* mutable_net_name();
  inline ::std::string* release_net_name();
  inline void set_allocated_net_name(::std::string* net_name);

  // required uint32 chip = 2;
  inline bool has_chip() const;
  inline void clear_chip();
  static const int kChipFieldNumber = 2;
  inline ::google::protobuf::uint32 chip() const;
  inline void set_chip(::google::protobuf::uint32 value);

  // optional uint32 node_num = 3 [default = 1];
  inline bool has_node_num() const;
  inline void clear_node_num();
  static const int kNodeNumFieldNumber = 3;
  inline ::google::protobuf::uint32 node_num() const;
  inline void set_node_num(::google::protobuf::uint32 value);

  // required uint32 fmt = 4;
  inline bool has_fmt() const;
  inline void clear_fmt();
  static const int kFmtFieldNumber = 4;
  inline ::google::protobuf::uint32 fmt() const;
  inline void set_fmt(::google::protobuf::uint32 value);

  // repeated .bmodel.Command command = 5;
  inline int command_size() const;
  inline void clear_command();
  static const int kCommandFieldNumber = 5;
  inline const ::bmodel::Command& command(int index) const;
  inline ::bmodel::Command* mutable_command(int index);
  inline ::bmodel::Command* add_command();
  inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Command >&
      command() const;
  inline ::google::protobuf::RepeatedPtrField< ::bmodel::Command >*
      mutable_command();

  // repeated bytes weight = 6;
  inline int weight_size() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 6;
  inline const ::std::string& weight(int index) const;
  inline ::std::string* mutable_weight(int index);
  inline void set_weight(int index, const ::std::string& value);
  inline void set_weight(int index, const char* value);
  inline void set_weight(int index, const void* value, size_t size);
  inline ::std::string* add_weight();
  inline void add_weight(const ::std::string& value);
  inline void add_weight(const char* value);
  inline void add_weight(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& weight() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_weight();

  // repeated .bmodel.Library library = 7;
  inline int library_size() const;
  inline void clear_library();
  static const int kLibraryFieldNumber = 7;
  inline const ::bmodel::Library& library(int index) const;
  inline ::bmodel::Library* mutable_library(int index);
  inline ::bmodel::Library* add_library();
  inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Library >&
      library() const;
  inline ::google::protobuf::RepeatedPtrField< ::bmodel::Library >*
      mutable_library();

  // @@protoc_insertion_point(class_scope:bmodel.Model)
 private:
  inline void set_has_net_name();
  inline void clear_has_net_name();
  inline void set_has_chip();
  inline void clear_has_chip();
  inline void set_has_node_num();
  inline void clear_has_node_num();
  inline void set_has_fmt();
  inline void clear_has_fmt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* net_name_;
  ::google::protobuf::uint32 chip_;
  ::google::protobuf::uint32 node_num_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Command > command_;
  ::google::protobuf::RepeatedPtrField< ::std::string> weight_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Library > library_;
  ::google::protobuf::uint32 fmt_;
  friend void  protobuf_AddDesc_bmodel_2eproto();
  friend void protobuf_AssignDesc_bmodel_2eproto();
  friend void protobuf_ShutdownFile_bmodel_2eproto();

  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// ===================================================================


// ===================================================================

// Shape

// repeated uint32 dim = 1 [packed = true];
inline int Shape::dim_size() const {
  return dim_.size();
}
inline void Shape::clear_dim() {
  dim_.Clear();
}
inline ::google::protobuf::uint32 Shape::dim(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Shape.dim)
  return dim_.Get(index);
}
inline void Shape::set_dim(int index, ::google::protobuf::uint32 value) {
  dim_.Set(index, value);
  // @@protoc_insertion_point(field_set:bmodel.Shape.dim)
}
inline void Shape::add_dim(::google::protobuf::uint32 value) {
  dim_.Add(value);
  // @@protoc_insertion_point(field_add:bmodel.Shape.dim)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Shape::dim() const {
  // @@protoc_insertion_point(field_list:bmodel.Shape.dim)
  return dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Shape::mutable_dim() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Shape.dim)
  return &dim_;
}

// -------------------------------------------------------------------

// Output

// required string name = 1;
inline bool Output::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Output::name() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.name)
  return *name_;
}
inline void Output::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:bmodel.Output.name)
}
inline void Output::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Output.name)
}
inline void Output::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Output.name)
}
inline ::std::string* Output::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Output.name)
  return name_;
}
inline ::std::string* Output::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Output::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Output.name)
}

// required .bmodel.Shape shape = 2;
inline bool Output::has_shape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_shape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_shape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_shape() {
  if (shape_ != NULL) shape_->::bmodel::Shape::Clear();
  clear_has_shape();
}
inline const ::bmodel::Shape& Output::shape() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.shape)
  return shape_ != NULL ? *shape_ : *default_instance_->shape_;
}
inline ::bmodel::Shape* Output::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) shape_ = new ::bmodel::Shape;
  // @@protoc_insertion_point(field_mutable:bmodel.Output.shape)
  return shape_;
}
inline ::bmodel::Shape* Output::release_shape() {
  clear_has_shape();
  ::bmodel::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline void Output::set_allocated_shape(::bmodel::Shape* shape) {
  delete shape_;
  shape_ = shape;
  if (shape) {
    set_has_shape();
  } else {
    clear_has_shape();
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Output.shape)
}

// required uint64 offset = 3;
inline bool Output::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Output::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Output::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Output::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Output::offset() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.offset)
  return offset_;
}
inline void Output::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Output.offset)
}

// optional float threshold = 4 [default = 0];
inline bool Output::has_threshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Output::set_has_threshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Output::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Output::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline float Output::threshold() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.threshold)
  return threshold_;
}
inline void Output::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Output.threshold)
}

// -------------------------------------------------------------------

// Input

// required .bmodel.Shape shape = 1;
inline bool Input::has_shape() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_shape() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_shape() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_shape() {
  if (shape_ != NULL) shape_->::bmodel::Shape::Clear();
  clear_has_shape();
}
inline const ::bmodel::Shape& Input::shape() const {
  // @@protoc_insertion_point(field_get:bmodel.Input.shape)
  return shape_ != NULL ? *shape_ : *default_instance_->shape_;
}
inline ::bmodel::Shape* Input::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) shape_ = new ::bmodel::Shape;
  // @@protoc_insertion_point(field_mutable:bmodel.Input.shape)
  return shape_;
}
inline ::bmodel::Shape* Input::release_shape() {
  clear_has_shape();
  ::bmodel::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline void Input::set_allocated_shape(::bmodel::Shape* shape) {
  delete shape_;
  shape_ = shape;
  if (shape) {
    set_has_shape();
  } else {
    clear_has_shape();
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Input.shape)
}

// optional float threshold = 2 [default = 0];
inline bool Input::has_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline float Input::threshold() const {
  // @@protoc_insertion_point(field_get:bmodel.Input.threshold)
  return threshold_;
}
inline void Input::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Input.threshold)
}

// -------------------------------------------------------------------

// Command

// repeated .bmodel.Input input = 1;
inline int Command::input_size() const {
  return input_.size();
}
inline void Command::clear_input() {
  input_.Clear();
}
inline const ::bmodel::Input& Command::input(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Command.input)
  return input_.Get(index);
}
inline ::bmodel::Input* Command::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Command.input)
  return input_.Mutable(index);
}
inline ::bmodel::Input* Command::add_input() {
  // @@protoc_insertion_point(field_add:bmodel.Command.input)
  return input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Input >&
Command::input() const {
  // @@protoc_insertion_point(field_list:bmodel.Command.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Input >*
Command::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Command.input)
  return &input_;
}

// required bytes cmdbuf = 2;
inline bool Command::has_cmdbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_cmdbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_cmdbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_cmdbuf() {
  if (cmdbuf_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmdbuf_->clear();
  }
  clear_has_cmdbuf();
}
inline const ::std::string& Command::cmdbuf() const {
  // @@protoc_insertion_point(field_get:bmodel.Command.cmdbuf)
  return *cmdbuf_;
}
inline void Command::set_cmdbuf(const ::std::string& value) {
  set_has_cmdbuf();
  if (cmdbuf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmdbuf_ = new ::std::string;
  }
  cmdbuf_->assign(value);
  // @@protoc_insertion_point(field_set:bmodel.Command.cmdbuf)
}
inline void Command::set_cmdbuf(const char* value) {
  set_has_cmdbuf();
  if (cmdbuf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmdbuf_ = new ::std::string;
  }
  cmdbuf_->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Command.cmdbuf)
}
inline void Command::set_cmdbuf(const void* value, size_t size) {
  set_has_cmdbuf();
  if (cmdbuf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmdbuf_ = new ::std::string;
  }
  cmdbuf_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Command.cmdbuf)
}
inline ::std::string* Command::mutable_cmdbuf() {
  set_has_cmdbuf();
  if (cmdbuf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cmdbuf_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Command.cmdbuf)
  return cmdbuf_;
}
inline ::std::string* Command::release_cmdbuf() {
  clear_has_cmdbuf();
  if (cmdbuf_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cmdbuf_;
    cmdbuf_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Command::set_allocated_cmdbuf(::std::string* cmdbuf) {
  if (cmdbuf_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cmdbuf_;
  }
  if (cmdbuf) {
    set_has_cmdbuf();
    cmdbuf_ = cmdbuf;
  } else {
    clear_has_cmdbuf();
    cmdbuf_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Command.cmdbuf)
}

// required uint64 neuron_size = 3;
inline bool Command::has_neuron_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_neuron_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_neuron_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_neuron_size() {
  neuron_size_ = GOOGLE_ULONGLONG(0);
  clear_has_neuron_size();
}
inline ::google::protobuf::uint64 Command::neuron_size() const {
  // @@protoc_insertion_point(field_get:bmodel.Command.neuron_size)
  return neuron_size_;
}
inline void Command::set_neuron_size(::google::protobuf::uint64 value) {
  set_has_neuron_size();
  neuron_size_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Command.neuron_size)
}

// repeated .bmodel.Output output = 4;
inline int Command::output_size() const {
  return output_.size();
}
inline void Command::clear_output() {
  output_.Clear();
}
inline const ::bmodel::Output& Command::output(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Command.output)
  return output_.Get(index);
}
inline ::bmodel::Output* Command::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Command.output)
  return output_.Mutable(index);
}
inline ::bmodel::Output* Command::add_output() {
  // @@protoc_insertion_point(field_add:bmodel.Command.output)
  return output_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Output >&
Command::output() const {
  // @@protoc_insertion_point(field_list:bmodel.Command.output)
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Output >*
Command::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Command.output)
  return &output_;
}

// optional uint32 weight_index = 5 [default = 0];
inline bool Command::has_weight_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command::set_has_weight_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command::clear_has_weight_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command::clear_weight_index() {
  weight_index_ = 0u;
  clear_has_weight_index();
}
inline ::google::protobuf::uint32 Command::weight_index() const {
  // @@protoc_insertion_point(field_get:bmodel.Command.weight_index)
  return weight_index_;
}
inline void Command::set_weight_index(::google::protobuf::uint32 value) {
  set_has_weight_index();
  weight_index_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Command.weight_index)
}

// -------------------------------------------------------------------

// Library

// required string name = 1;
inline bool Library::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Library::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Library::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Library::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Library::name() const {
  // @@protoc_insertion_point(field_get:bmodel.Library.name)
  return *name_;
}
inline void Library::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:bmodel.Library.name)
}
inline void Library::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Library.name)
}
inline void Library::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Library.name)
}
inline ::std::string* Library::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Library.name)
  return name_;
}
inline ::std::string* Library::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Library::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Library.name)
}

// required bytes lib_x86_64 = 2;
inline bool Library::has_lib_x86_64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Library::set_has_lib_x86_64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Library::clear_has_lib_x86_64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Library::clear_lib_x86_64() {
  if (lib_x86_64_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_x86_64_->clear();
  }
  clear_has_lib_x86_64();
}
inline const ::std::string& Library::lib_x86_64() const {
  // @@protoc_insertion_point(field_get:bmodel.Library.lib_x86_64)
  return *lib_x86_64_;
}
inline void Library::set_lib_x86_64(const ::std::string& value) {
  set_has_lib_x86_64();
  if (lib_x86_64_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_x86_64_ = new ::std::string;
  }
  lib_x86_64_->assign(value);
  // @@protoc_insertion_point(field_set:bmodel.Library.lib_x86_64)
}
inline void Library::set_lib_x86_64(const char* value) {
  set_has_lib_x86_64();
  if (lib_x86_64_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_x86_64_ = new ::std::string;
  }
  lib_x86_64_->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Library.lib_x86_64)
}
inline void Library::set_lib_x86_64(const void* value, size_t size) {
  set_has_lib_x86_64();
  if (lib_x86_64_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_x86_64_ = new ::std::string;
  }
  lib_x86_64_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Library.lib_x86_64)
}
inline ::std::string* Library::mutable_lib_x86_64() {
  set_has_lib_x86_64();
  if (lib_x86_64_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_x86_64_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Library.lib_x86_64)
  return lib_x86_64_;
}
inline ::std::string* Library::release_lib_x86_64() {
  clear_has_lib_x86_64();
  if (lib_x86_64_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lib_x86_64_;
    lib_x86_64_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Library::set_allocated_lib_x86_64(::std::string* lib_x86_64) {
  if (lib_x86_64_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lib_x86_64_;
  }
  if (lib_x86_64) {
    set_has_lib_x86_64();
    lib_x86_64_ = lib_x86_64;
  } else {
    clear_has_lib_x86_64();
    lib_x86_64_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Library.lib_x86_64)
}

// required bytes lib_armv8 = 3;
inline bool Library::has_lib_armv8() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Library::set_has_lib_armv8() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Library::clear_has_lib_armv8() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Library::clear_lib_armv8() {
  if (lib_armv8_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_armv8_->clear();
  }
  clear_has_lib_armv8();
}
inline const ::std::string& Library::lib_armv8() const {
  // @@protoc_insertion_point(field_get:bmodel.Library.lib_armv8)
  return *lib_armv8_;
}
inline void Library::set_lib_armv8(const ::std::string& value) {
  set_has_lib_armv8();
  if (lib_armv8_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_armv8_ = new ::std::string;
  }
  lib_armv8_->assign(value);
  // @@protoc_insertion_point(field_set:bmodel.Library.lib_armv8)
}
inline void Library::set_lib_armv8(const char* value) {
  set_has_lib_armv8();
  if (lib_armv8_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_armv8_ = new ::std::string;
  }
  lib_armv8_->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Library.lib_armv8)
}
inline void Library::set_lib_armv8(const void* value, size_t size) {
  set_has_lib_armv8();
  if (lib_armv8_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_armv8_ = new ::std::string;
  }
  lib_armv8_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Library.lib_armv8)
}
inline ::std::string* Library::mutable_lib_armv8() {
  set_has_lib_armv8();
  if (lib_armv8_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    lib_armv8_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Library.lib_armv8)
  return lib_armv8_;
}
inline ::std::string* Library::release_lib_armv8() {
  clear_has_lib_armv8();
  if (lib_armv8_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = lib_armv8_;
    lib_armv8_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Library::set_allocated_lib_armv8(::std::string* lib_armv8) {
  if (lib_armv8_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete lib_armv8_;
  }
  if (lib_armv8) {
    set_has_lib_armv8();
    lib_armv8_ = lib_armv8;
  } else {
    clear_has_lib_armv8();
    lib_armv8_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Library.lib_armv8)
}

// -------------------------------------------------------------------

// Model

// required string net_name = 1;
inline bool Model::has_net_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_net_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_net_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_net_name() {
  if (net_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_name_->clear();
  }
  clear_has_net_name();
}
inline const ::std::string& Model::net_name() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.net_name)
  return *net_name_;
}
inline void Model::set_net_name(const ::std::string& value) {
  set_has_net_name();
  if (net_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_name_ = new ::std::string;
  }
  net_name_->assign(value);
  // @@protoc_insertion_point(field_set:bmodel.Model.net_name)
}
inline void Model::set_net_name(const char* value) {
  set_has_net_name();
  if (net_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_name_ = new ::std::string;
  }
  net_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Model.net_name)
}
inline void Model::set_net_name(const char* value, size_t size) {
  set_has_net_name();
  if (net_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_name_ = new ::std::string;
  }
  net_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Model.net_name)
}
inline ::std::string* Model::mutable_net_name() {
  set_has_net_name();
  if (net_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    net_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Model.net_name)
  return net_name_;
}
inline ::std::string* Model::release_net_name() {
  clear_has_net_name();
  if (net_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = net_name_;
    net_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Model::set_allocated_net_name(::std::string* net_name) {
  if (net_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete net_name_;
  }
  if (net_name) {
    set_has_net_name();
    net_name_ = net_name;
  } else {
    clear_has_net_name();
    net_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:bmodel.Model.net_name)
}

// required uint32 chip = 2;
inline bool Model::has_chip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Model::set_has_chip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Model::clear_has_chip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Model::clear_chip() {
  chip_ = 0u;
  clear_has_chip();
}
inline ::google::protobuf::uint32 Model::chip() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.chip)
  return chip_;
}
inline void Model::set_chip(::google::protobuf::uint32 value) {
  set_has_chip();
  chip_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Model.chip)
}

// optional uint32 node_num = 3 [default = 1];
inline bool Model::has_node_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Model::set_has_node_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Model::clear_has_node_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Model::clear_node_num() {
  node_num_ = 1u;
  clear_has_node_num();
}
inline ::google::protobuf::uint32 Model::node_num() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.node_num)
  return node_num_;
}
inline void Model::set_node_num(::google::protobuf::uint32 value) {
  set_has_node_num();
  node_num_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Model.node_num)
}

// required uint32 fmt = 4;
inline bool Model::has_fmt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Model::set_has_fmt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Model::clear_has_fmt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Model::clear_fmt() {
  fmt_ = 0u;
  clear_has_fmt();
}
inline ::google::protobuf::uint32 Model::fmt() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.fmt)
  return fmt_;
}
inline void Model::set_fmt(::google::protobuf::uint32 value) {
  set_has_fmt();
  fmt_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Model.fmt)
}

// repeated .bmodel.Command command = 5;
inline int Model::command_size() const {
  return command_.size();
}
inline void Model::clear_command() {
  command_.Clear();
}
inline const ::bmodel::Command& Model::command(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Model.command)
  return command_.Get(index);
}
inline ::bmodel::Command* Model::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Model.command)
  return command_.Mutable(index);
}
inline ::bmodel::Command* Model::add_command() {
  // @@protoc_insertion_point(field_add:bmodel.Model.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Command >&
Model::command() const {
  // @@protoc_insertion_point(field_list:bmodel.Model.command)
  return command_;
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Command >*
Model::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Model.command)
  return &command_;
}

// repeated bytes weight = 6;
inline int Model::weight_size() const {
  return weight_.size();
}
inline void Model::clear_weight() {
  weight_.Clear();
}
inline const ::std::string& Model::weight(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Model.weight)
  return weight_.Get(index);
}
inline ::std::string* Model::mutable_weight(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Model.weight)
  return weight_.Mutable(index);
}
inline void Model::set_weight(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bmodel.Model.weight)
  weight_.Mutable(index)->assign(value);
}
inline void Model::set_weight(int index, const char* value) {
  weight_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Model.weight)
}
inline void Model::set_weight(int index, const void* value, size_t size) {
  weight_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Model.weight)
}
inline ::std::string* Model::add_weight() {
  return weight_.Add();
}
inline void Model::add_weight(const ::std::string& value) {
  weight_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bmodel.Model.weight)
}
inline void Model::add_weight(const char* value) {
  weight_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bmodel.Model.weight)
}
inline void Model::add_weight(const void* value, size_t size) {
  weight_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bmodel.Model.weight)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Model::weight() const {
  // @@protoc_insertion_point(field_list:bmodel.Model.weight)
  return weight_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Model::mutable_weight() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Model.weight)
  return &weight_;
}

// repeated .bmodel.Library library = 7;
inline int Model::library_size() const {
  return library_.size();
}
inline void Model::clear_library() {
  library_.Clear();
}
inline const ::bmodel::Library& Model::library(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Model.library)
  return library_.Get(index);
}
inline ::bmodel::Library* Model::mutable_library(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Model.library)
  return library_.Mutable(index);
}
inline ::bmodel::Library* Model::add_library() {
  // @@protoc_insertion_point(field_add:bmodel.Model.library)
  return library_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Library >&
Model::library() const {
  // @@protoc_insertion_point(field_list:bmodel.Model.library)
  return library_;
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Library >*
Model::mutable_library() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Model.library)
  return &library_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace bmodel

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bmodel_2eproto__INCLUDED
