// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bmodel.proto

#ifndef PROTOBUF_INCLUDED_bmodel_2eproto
#define PROTOBUF_INCLUDED_bmodel_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_bmodel_2eproto 

namespace protobuf_bmodel_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_bmodel_2eproto
namespace bmodel {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class Input;
class InputDefaultTypeInternal;
extern InputDefaultTypeInternal _Input_default_instance_;
class Library;
class LibraryDefaultTypeInternal;
extern LibraryDefaultTypeInternal _Library_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Output;
class OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Shape;
class ShapeDefaultTypeInternal;
extern ShapeDefaultTypeInternal _Shape_default_instance_;
class Weight;
class WeightDefaultTypeInternal;
extern WeightDefaultTypeInternal _Weight_default_instance_;
}  // namespace bmodel
namespace google {
namespace protobuf {
template<> ::bmodel::Command* Arena::CreateMaybeMessage<::bmodel::Command>(Arena*);
template<> ::bmodel::Input* Arena::CreateMaybeMessage<::bmodel::Input>(Arena*);
template<> ::bmodel::Library* Arena::CreateMaybeMessage<::bmodel::Library>(Arena*);
template<> ::bmodel::Model* Arena::CreateMaybeMessage<::bmodel::Model>(Arena*);
template<> ::bmodel::Output* Arena::CreateMaybeMessage<::bmodel::Output>(Arena*);
template<> ::bmodel::Shape* Arena::CreateMaybeMessage<::bmodel::Shape>(Arena*);
template<> ::bmodel::Weight* Arena::CreateMaybeMessage<::bmodel::Weight>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace bmodel {

// ===================================================================

class Shape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bmodel.Shape) */ {
 public:
  Shape();
  virtual ~Shape();

  Shape(const Shape& from);

  inline Shape& operator=(const Shape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Shape(Shape&& from) noexcept
    : Shape() {
    *this = ::std::move(from);
  }

  inline Shape& operator=(Shape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Shape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Shape* internal_default_instance() {
    return reinterpret_cast<const Shape*>(
               &_Shape_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Shape* other);
  friend void swap(Shape& a, Shape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Shape* New() const final {
    return CreateMaybeMessage<Shape>(NULL);
  }

  Shape* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Shape>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Shape& from);
  void MergeFrom(const Shape& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 dim = 1 [packed = true];
  int dim_size() const;
  void clear_dim();
  static const int kDimFieldNumber = 1;
  ::google::protobuf::uint32 dim(int index) const;
  void set_dim(int index, ::google::protobuf::uint32 value);
  void add_dim(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      dim() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_dim();

  // @@protoc_insertion_point(class_scope:bmodel.Shape)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > dim_;
  mutable int _dim_cached_byte_size_;
  friend struct ::protobuf_bmodel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bmodel.Output) */ {
 public:
  Output();
  virtual ~Output();

  Output(const Output& from);

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Output* other);
  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Output* New() const final {
    return CreateMaybeMessage<Output>(NULL);
  }

  Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Output& from);
  void MergeFrom(const Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .bmodel.Shape shape = 2;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  private:
  const ::bmodel::Shape& _internal_shape() const;
  public:
  const ::bmodel::Shape& shape() const;
  ::bmodel::Shape* release_shape();
  ::bmodel::Shape* mutable_shape();
  void set_allocated_shape(::bmodel::Shape* shape);

  // required uint64 offset = 3;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // optional float threshold = 4 [default = 0];
  bool has_threshold() const;
  void clear_threshold();
  static const int kThresholdFieldNumber = 4;
  float threshold() const;
  void set_threshold(float value);

  // optional uint32 fmt = 5;
  bool has_fmt() const;
  void clear_fmt();
  static const int kFmtFieldNumber = 5;
  ::google::protobuf::uint32 fmt() const;
  void set_fmt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bmodel.Output)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_shape();
  void clear_has_shape();
  void set_has_offset();
  void clear_has_offset();
  void set_has_threshold();
  void clear_has_threshold();
  void set_has_fmt();
  void clear_has_fmt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::bmodel::Shape* shape_;
  ::google::protobuf::uint64 offset_;
  float threshold_;
  ::google::protobuf::uint32 fmt_;
  friend struct ::protobuf_bmodel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bmodel.Input) */ {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Input(Input&& from) noexcept
    : Input() {
    *this = ::std::move(from);
  }

  inline Input& operator=(Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Input* internal_default_instance() {
    return reinterpret_cast<const Input*>(
               &_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Input* other);
  friend void swap(Input& a, Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Input* New() const final {
    return CreateMaybeMessage<Input>(NULL);
  }

  Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .bmodel.Shape shape = 1;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 1;
  private:
  const ::bmodel::Shape& _internal_shape() const;
  public:
  const ::bmodel::Shape& shape() const;
  ::bmodel::Shape* release_shape();
  ::bmodel::Shape* mutable_shape();
  void set_allocated_shape(::bmodel::Shape* shape);

  // optional float threshold = 2 [default = 0];
  bool has_threshold() const;
  void clear_threshold();
  static const int kThresholdFieldNumber = 2;
  float threshold() const;
  void set_threshold(float value);

  // optional uint32 fmt = 3;
  bool has_fmt() const;
  void clear_fmt();
  static const int kFmtFieldNumber = 3;
  ::google::protobuf::uint32 fmt() const;
  void set_fmt(::google::protobuf::uint32 value);

  // optional uint64 offset = 4 [default = 0];
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint64 offset() const;
  void set_offset(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bmodel.Input)
 private:
  void set_has_shape();
  void clear_has_shape();
  void set_has_threshold();
  void clear_has_threshold();
  void set_has_fmt();
  void clear_has_fmt();
  void set_has_offset();
  void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::bmodel::Shape* shape_;
  float threshold_;
  ::google::protobuf::uint32 fmt_;
  ::google::protobuf::uint64 offset_;
  friend struct ::protobuf_bmodel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bmodel.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(NULL);
  }

  Command* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bmodel.Input input = 1;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  ::bmodel::Input* mutable_input(int index);
  ::google::protobuf::RepeatedPtrField< ::bmodel::Input >*
      mutable_input();
  const ::bmodel::Input& input(int index) const;
  ::bmodel::Input* add_input();
  const ::google::protobuf::RepeatedPtrField< ::bmodel::Input >&
      input() const;

  // repeated .bmodel.Output output = 4;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 4;
  ::bmodel::Output* mutable_output(int index);
  ::google::protobuf::RepeatedPtrField< ::bmodel::Output >*
      mutable_output();
  const ::bmodel::Output& output(int index) const;
  ::bmodel::Output* add_output();
  const ::google::protobuf::RepeatedPtrField< ::bmodel::Output >&
      output() const;

  // required bytes cmdbuf = 2;
  bool has_cmdbuf() const;
  void clear_cmdbuf();
  static const int kCmdbufFieldNumber = 2;
  const ::std::string& cmdbuf() const;
  void set_cmdbuf(const ::std::string& value);
  #if LANG_CXX11
  void set_cmdbuf(::std::string&& value);
  #endif
  void set_cmdbuf(const char* value);
  void set_cmdbuf(const void* value, size_t size);
  ::std::string* mutable_cmdbuf();
  ::std::string* release_cmdbuf();
  void set_allocated_cmdbuf(::std::string* cmdbuf);

  // required uint64 neuron_size = 3;
  bool has_neuron_size() const;
  void clear_neuron_size();
  static const int kNeuronSizeFieldNumber = 3;
  ::google::protobuf::uint64 neuron_size() const;
  void set_neuron_size(::google::protobuf::uint64 value);

  // optional uint32 weight_index = 5 [default = 0];
  bool has_weight_index() const;
  void clear_weight_index();
  static const int kWeightIndexFieldNumber = 5;
  ::google::protobuf::uint32 weight_index() const;
  void set_weight_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bmodel.Command)
 private:
  void set_has_cmdbuf();
  void clear_has_cmdbuf();
  void set_has_neuron_size();
  void clear_has_neuron_size();
  void set_has_weight_index();
  void clear_has_weight_index();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Input > input_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Output > output_;
  ::google::protobuf::internal::ArenaStringPtr cmdbuf_;
  ::google::protobuf::uint64 neuron_size_;
  ::google::protobuf::uint32 weight_index_;
  friend struct ::protobuf_bmodel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Library : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bmodel.Library) */ {
 public:
  Library();
  virtual ~Library();

  Library(const Library& from);

  inline Library& operator=(const Library& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Library(Library&& from) noexcept
    : Library() {
    *this = ::std::move(from);
  }

  inline Library& operator=(Library&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Library& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Library* internal_default_instance() {
    return reinterpret_cast<const Library*>(
               &_Library_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Library* other);
  friend void swap(Library& a, Library& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Library* New() const final {
    return CreateMaybeMessage<Library>(NULL);
  }

  Library* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Library>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Library& from);
  void MergeFrom(const Library& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Library* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required bytes lib_x86_64 = 2;
  bool has_lib_x86_64() const;
  void clear_lib_x86_64();
  static const int kLibX8664FieldNumber = 2;
  const ::std::string& lib_x86_64() const;
  void set_lib_x86_64(const ::std::string& value);
  #if LANG_CXX11
  void set_lib_x86_64(::std::string&& value);
  #endif
  void set_lib_x86_64(const char* value);
  void set_lib_x86_64(const void* value, size_t size);
  ::std::string* mutable_lib_x86_64();
  ::std::string* release_lib_x86_64();
  void set_allocated_lib_x86_64(::std::string* lib_x86_64);

  // required bytes lib_armv8 = 3;
  bool has_lib_armv8() const;
  void clear_lib_armv8();
  static const int kLibArmv8FieldNumber = 3;
  const ::std::string& lib_armv8() const;
  void set_lib_armv8(const ::std::string& value);
  #if LANG_CXX11
  void set_lib_armv8(::std::string&& value);
  #endif
  void set_lib_armv8(const char* value);
  void set_lib_armv8(const void* value, size_t size);
  ::std::string* mutable_lib_armv8();
  ::std::string* release_lib_armv8();
  void set_allocated_lib_armv8(::std::string* lib_armv8);

  // @@protoc_insertion_point(class_scope:bmodel.Library)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_lib_x86_64();
  void clear_has_lib_x86_64();
  void set_has_lib_armv8();
  void clear_has_lib_armv8();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr lib_x86_64_;
  ::google::protobuf::internal::ArenaStringPtr lib_armv8_;
  friend struct ::protobuf_bmodel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Weight : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bmodel.Weight) */ {
 public:
  Weight();
  virtual ~Weight();

  Weight(const Weight& from);

  inline Weight& operator=(const Weight& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Weight(Weight&& from) noexcept
    : Weight() {
    *this = ::std::move(from);
  }

  inline Weight& operator=(Weight&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Weight& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Weight* internal_default_instance() {
    return reinterpret_cast<const Weight*>(
               &_Weight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Weight* other);
  friend void swap(Weight& a, Weight& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Weight* New() const final {
    return CreateMaybeMessage<Weight>(NULL);
  }

  Weight* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Weight>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Weight& from);
  void MergeFrom(const Weight& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Weight* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 weight_offset = 1;
  bool has_weight_offset() const;
  void clear_weight_offset();
  static const int kWeightOffsetFieldNumber = 1;
  ::google::protobuf::uint64 weight_offset() const;
  void set_weight_offset(::google::protobuf::uint64 value);

  // required uint64 weight_length = 2;
  bool has_weight_length() const;
  void clear_weight_length();
  static const int kWeightLengthFieldNumber = 2;
  ::google::protobuf::uint64 weight_length() const;
  void set_weight_length(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:bmodel.Weight)
 private:
  void set_has_weight_offset();
  void clear_has_weight_offset();
  void set_has_weight_length();
  void clear_has_weight_length();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 weight_offset_;
  ::google::protobuf::uint64 weight_length_;
  friend struct ::protobuf_bmodel_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bmodel.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const final {
    return CreateMaybeMessage<Model>(NULL);
  }

  Model* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bmodel.Command command = 5;
  int command_size() const;
  void clear_command();
  static const int kCommandFieldNumber = 5;
  ::bmodel::Command* mutable_command(int index);
  ::google::protobuf::RepeatedPtrField< ::bmodel::Command >*
      mutable_command();
  const ::bmodel::Command& command(int index) const;
  ::bmodel::Command* add_command();
  const ::google::protobuf::RepeatedPtrField< ::bmodel::Command >&
      command() const;

  // repeated bytes weight = 6;
  int weight_size() const;
  void clear_weight();
  static const int kWeightFieldNumber = 6;
  const ::std::string& weight(int index) const;
  ::std::string* mutable_weight(int index);
  void set_weight(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_weight(int index, ::std::string&& value);
  #endif
  void set_weight(int index, const char* value);
  void set_weight(int index, const void* value, size_t size);
  ::std::string* add_weight();
  void add_weight(const ::std::string& value);
  #if LANG_CXX11
  void add_weight(::std::string&& value);
  #endif
  void add_weight(const char* value);
  void add_weight(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& weight() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_weight();

  // repeated .bmodel.Library library = 7;
  int library_size() const;
  void clear_library();
  static const int kLibraryFieldNumber = 7;
  ::bmodel::Library* mutable_library(int index);
  ::google::protobuf::RepeatedPtrField< ::bmodel::Library >*
      mutable_library();
  const ::bmodel::Library& library(int index) const;
  ::bmodel::Library* add_library();
  const ::google::protobuf::RepeatedPtrField< ::bmodel::Library >&
      library() const;

  // repeated .bmodel.Weight weight_info = 10;
  int weight_info_size() const;
  void clear_weight_info();
  static const int kWeightInfoFieldNumber = 10;
  ::bmodel::Weight* mutable_weight_info(int index);
  ::google::protobuf::RepeatedPtrField< ::bmodel::Weight >*
      mutable_weight_info();
  const ::bmodel::Weight& weight_info(int index) const;
  ::bmodel::Weight* add_weight_info();
  const ::google::protobuf::RepeatedPtrField< ::bmodel::Weight >&
      weight_info() const;

  // required string net_name = 1;
  bool has_net_name() const;
  void clear_net_name();
  static const int kNetNameFieldNumber = 1;
  const ::std::string& net_name() const;
  void set_net_name(const ::std::string& value);
  #if LANG_CXX11
  void set_net_name(::std::string&& value);
  #endif
  void set_net_name(const char* value);
  void set_net_name(const char* value, size_t size);
  ::std::string* mutable_net_name();
  ::std::string* release_net_name();
  void set_allocated_net_name(::std::string* net_name);

  // optional string type = 8 [default = "A"];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 8;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string version = 9 [default = "2.1"];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 9;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // required uint32 chip = 2;
  bool has_chip() const;
  void clear_chip();
  static const int kChipFieldNumber = 2;
  ::google::protobuf::uint32 chip() const;
  void set_chip(::google::protobuf::uint32 value);

  // required uint32 fmt = 4;
  bool has_fmt() const;
  void clear_fmt();
  static const int kFmtFieldNumber = 4;
  ::google::protobuf::uint32 fmt() const;
  void set_fmt(::google::protobuf::uint32 value);

  // optional uint32 node_num = 3 [default = 1];
  bool has_node_num() const;
  void clear_node_num();
  static const int kNodeNumFieldNumber = 3;
  ::google::protobuf::uint32 node_num() const;
  void set_node_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:bmodel.Model)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_version();
  void clear_has_version();
  void set_has_net_name();
  void clear_has_net_name();
  void set_has_chip();
  void clear_has_chip();
  void set_has_node_num();
  void clear_has_node_num();
  void set_has_fmt();
  void clear_has_fmt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Command > command_;
  ::google::protobuf::RepeatedPtrField< ::std::string> weight_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Library > library_;
  ::google::protobuf::RepeatedPtrField< ::bmodel::Weight > weight_info_;
  ::google::protobuf::internal::ArenaStringPtr net_name_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_type_;
  private:
  ::google::protobuf::internal::ArenaStringPtr type_;
  public:
  static ::google::protobuf::internal::ExplicitlyConstructed< ::std::string> _i_give_permission_to_break_this_code_default_version_;
  private:
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::uint32 chip_;
  ::google::protobuf::uint32 fmt_;
  ::google::protobuf::uint32 node_num_;
  friend struct ::protobuf_bmodel_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Shape

// repeated uint32 dim = 1 [packed = true];
inline int Shape::dim_size() const {
  return dim_.size();
}
inline void Shape::clear_dim() {
  dim_.Clear();
}
inline ::google::protobuf::uint32 Shape::dim(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Shape.dim)
  return dim_.Get(index);
}
inline void Shape::set_dim(int index, ::google::protobuf::uint32 value) {
  dim_.Set(index, value);
  // @@protoc_insertion_point(field_set:bmodel.Shape.dim)
}
inline void Shape::add_dim(::google::protobuf::uint32 value) {
  dim_.Add(value);
  // @@protoc_insertion_point(field_add:bmodel.Shape.dim)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Shape::dim() const {
  // @@protoc_insertion_point(field_list:bmodel.Shape.dim)
  return dim_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Shape::mutable_dim() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Shape.dim)
  return &dim_;
}

// -------------------------------------------------------------------

// Output

// required string name = 1;
inline bool Output::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Output::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Output::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Output::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Output::name() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.name)
  return name_.GetNoArena();
}
inline void Output::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bmodel.Output.name)
}
#if LANG_CXX11
inline void Output::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Output.name)
}
#endif
inline void Output::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Output.name)
}
inline void Output::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Output.name)
}
inline ::std::string* Output::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:bmodel.Output.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Output::release_name() {
  // @@protoc_insertion_point(field_release:bmodel.Output.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Output::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Output.name)
}

// required .bmodel.Shape shape = 2;
inline bool Output::has_shape() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Output::set_has_shape() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Output::clear_has_shape() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Output::clear_shape() {
  if (shape_ != NULL) shape_->Clear();
  clear_has_shape();
}
inline const ::bmodel::Shape& Output::_internal_shape() const {
  return *shape_;
}
inline const ::bmodel::Shape& Output::shape() const {
  const ::bmodel::Shape* p = shape_;
  // @@protoc_insertion_point(field_get:bmodel.Output.shape)
  return p != NULL ? *p : *reinterpret_cast<const ::bmodel::Shape*>(
      &::bmodel::_Shape_default_instance_);
}
inline ::bmodel::Shape* Output::release_shape() {
  // @@protoc_insertion_point(field_release:bmodel.Output.shape)
  clear_has_shape();
  ::bmodel::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline ::bmodel::Shape* Output::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) {
    auto* p = CreateMaybeMessage<::bmodel::Shape>(GetArenaNoVirtual());
    shape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Output.shape)
  return shape_;
}
inline void Output::set_allocated_shape(::bmodel::Shape* shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shape_;
  }
  if (shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    set_has_shape();
  } else {
    clear_has_shape();
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:bmodel.Output.shape)
}

// required uint64 offset = 3;
inline bool Output::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Output::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Output::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Output::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Output::offset() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.offset)
  return offset_;
}
inline void Output::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Output.offset)
}

// optional float threshold = 4 [default = 0];
inline bool Output::has_threshold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Output::set_has_threshold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Output::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Output::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline float Output::threshold() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.threshold)
  return threshold_;
}
inline void Output::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Output.threshold)
}

// optional uint32 fmt = 5;
inline bool Output::has_fmt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Output::set_has_fmt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Output::clear_has_fmt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Output::clear_fmt() {
  fmt_ = 0u;
  clear_has_fmt();
}
inline ::google::protobuf::uint32 Output::fmt() const {
  // @@protoc_insertion_point(field_get:bmodel.Output.fmt)
  return fmt_;
}
inline void Output::set_fmt(::google::protobuf::uint32 value) {
  set_has_fmt();
  fmt_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Output.fmt)
}

// -------------------------------------------------------------------

// Input

// required .bmodel.Shape shape = 1;
inline bool Input::has_shape() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_shape() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_shape() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_shape() {
  if (shape_ != NULL) shape_->Clear();
  clear_has_shape();
}
inline const ::bmodel::Shape& Input::_internal_shape() const {
  return *shape_;
}
inline const ::bmodel::Shape& Input::shape() const {
  const ::bmodel::Shape* p = shape_;
  // @@protoc_insertion_point(field_get:bmodel.Input.shape)
  return p != NULL ? *p : *reinterpret_cast<const ::bmodel::Shape*>(
      &::bmodel::_Shape_default_instance_);
}
inline ::bmodel::Shape* Input::release_shape() {
  // @@protoc_insertion_point(field_release:bmodel.Input.shape)
  clear_has_shape();
  ::bmodel::Shape* temp = shape_;
  shape_ = NULL;
  return temp;
}
inline ::bmodel::Shape* Input::mutable_shape() {
  set_has_shape();
  if (shape_ == NULL) {
    auto* p = CreateMaybeMessage<::bmodel::Shape>(GetArenaNoVirtual());
    shape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bmodel.Input.shape)
  return shape_;
}
inline void Input::set_allocated_shape(::bmodel::Shape* shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shape_;
  }
  if (shape) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    set_has_shape();
  } else {
    clear_has_shape();
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:bmodel.Input.shape)
}

// optional float threshold = 2 [default = 0];
inline bool Input::has_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_threshold() {
  threshold_ = 0;
  clear_has_threshold();
}
inline float Input::threshold() const {
  // @@protoc_insertion_point(field_get:bmodel.Input.threshold)
  return threshold_;
}
inline void Input::set_threshold(float value) {
  set_has_threshold();
  threshold_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Input.threshold)
}

// optional uint32 fmt = 3;
inline bool Input::has_fmt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input::set_has_fmt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input::clear_has_fmt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input::clear_fmt() {
  fmt_ = 0u;
  clear_has_fmt();
}
inline ::google::protobuf::uint32 Input::fmt() const {
  // @@protoc_insertion_point(field_get:bmodel.Input.fmt)
  return fmt_;
}
inline void Input::set_fmt(::google::protobuf::uint32 value) {
  set_has_fmt();
  fmt_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Input.fmt)
}

// optional uint64 offset = 4 [default = 0];
inline bool Input::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Input::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Input::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Input::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Input::offset() const {
  // @@protoc_insertion_point(field_get:bmodel.Input.offset)
  return offset_;
}
inline void Input::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Input.offset)
}

// -------------------------------------------------------------------

// Command

// repeated .bmodel.Input input = 1;
inline int Command::input_size() const {
  return input_.size();
}
inline void Command::clear_input() {
  input_.Clear();
}
inline ::bmodel::Input* Command::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Command.input)
  return input_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Input >*
Command::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Command.input)
  return &input_;
}
inline const ::bmodel::Input& Command::input(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Command.input)
  return input_.Get(index);
}
inline ::bmodel::Input* Command::add_input() {
  // @@protoc_insertion_point(field_add:bmodel.Command.input)
  return input_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Input >&
Command::input() const {
  // @@protoc_insertion_point(field_list:bmodel.Command.input)
  return input_;
}

// required bytes cmdbuf = 2;
inline bool Command::has_cmdbuf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_cmdbuf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_cmdbuf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_cmdbuf() {
  cmdbuf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cmdbuf();
}
inline const ::std::string& Command::cmdbuf() const {
  // @@protoc_insertion_point(field_get:bmodel.Command.cmdbuf)
  return cmdbuf_.GetNoArena();
}
inline void Command::set_cmdbuf(const ::std::string& value) {
  set_has_cmdbuf();
  cmdbuf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bmodel.Command.cmdbuf)
}
#if LANG_CXX11
inline void Command::set_cmdbuf(::std::string&& value) {
  set_has_cmdbuf();
  cmdbuf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Command.cmdbuf)
}
#endif
inline void Command::set_cmdbuf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cmdbuf();
  cmdbuf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Command.cmdbuf)
}
inline void Command::set_cmdbuf(const void* value, size_t size) {
  set_has_cmdbuf();
  cmdbuf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Command.cmdbuf)
}
inline ::std::string* Command::mutable_cmdbuf() {
  set_has_cmdbuf();
  // @@protoc_insertion_point(field_mutable:bmodel.Command.cmdbuf)
  return cmdbuf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Command::release_cmdbuf() {
  // @@protoc_insertion_point(field_release:bmodel.Command.cmdbuf)
  if (!has_cmdbuf()) {
    return NULL;
  }
  clear_has_cmdbuf();
  return cmdbuf_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Command::set_allocated_cmdbuf(::std::string* cmdbuf) {
  if (cmdbuf != NULL) {
    set_has_cmdbuf();
  } else {
    clear_has_cmdbuf();
  }
  cmdbuf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmdbuf);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Command.cmdbuf)
}

// required uint64 neuron_size = 3;
inline bool Command::has_neuron_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_neuron_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_neuron_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_neuron_size() {
  neuron_size_ = GOOGLE_ULONGLONG(0);
  clear_has_neuron_size();
}
inline ::google::protobuf::uint64 Command::neuron_size() const {
  // @@protoc_insertion_point(field_get:bmodel.Command.neuron_size)
  return neuron_size_;
}
inline void Command::set_neuron_size(::google::protobuf::uint64 value) {
  set_has_neuron_size();
  neuron_size_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Command.neuron_size)
}

// repeated .bmodel.Output output = 4;
inline int Command::output_size() const {
  return output_.size();
}
inline void Command::clear_output() {
  output_.Clear();
}
inline ::bmodel::Output* Command::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Command.output)
  return output_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Output >*
Command::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Command.output)
  return &output_;
}
inline const ::bmodel::Output& Command::output(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Command.output)
  return output_.Get(index);
}
inline ::bmodel::Output* Command::add_output() {
  // @@protoc_insertion_point(field_add:bmodel.Command.output)
  return output_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Output >&
Command::output() const {
  // @@protoc_insertion_point(field_list:bmodel.Command.output)
  return output_;
}

// optional uint32 weight_index = 5 [default = 0];
inline bool Command::has_weight_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_weight_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_weight_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_weight_index() {
  weight_index_ = 0u;
  clear_has_weight_index();
}
inline ::google::protobuf::uint32 Command::weight_index() const {
  // @@protoc_insertion_point(field_get:bmodel.Command.weight_index)
  return weight_index_;
}
inline void Command::set_weight_index(::google::protobuf::uint32 value) {
  set_has_weight_index();
  weight_index_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Command.weight_index)
}

// -------------------------------------------------------------------

// Library

// required string name = 1;
inline bool Library::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Library::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Library::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Library::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Library::name() const {
  // @@protoc_insertion_point(field_get:bmodel.Library.name)
  return name_.GetNoArena();
}
inline void Library::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bmodel.Library.name)
}
#if LANG_CXX11
inline void Library::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Library.name)
}
#endif
inline void Library::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Library.name)
}
inline void Library::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Library.name)
}
inline ::std::string* Library::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:bmodel.Library.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Library::release_name() {
  // @@protoc_insertion_point(field_release:bmodel.Library.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Library::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Library.name)
}

// required bytes lib_x86_64 = 2;
inline bool Library::has_lib_x86_64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Library::set_has_lib_x86_64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Library::clear_has_lib_x86_64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Library::clear_lib_x86_64() {
  lib_x86_64_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lib_x86_64();
}
inline const ::std::string& Library::lib_x86_64() const {
  // @@protoc_insertion_point(field_get:bmodel.Library.lib_x86_64)
  return lib_x86_64_.GetNoArena();
}
inline void Library::set_lib_x86_64(const ::std::string& value) {
  set_has_lib_x86_64();
  lib_x86_64_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bmodel.Library.lib_x86_64)
}
#if LANG_CXX11
inline void Library::set_lib_x86_64(::std::string&& value) {
  set_has_lib_x86_64();
  lib_x86_64_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Library.lib_x86_64)
}
#endif
inline void Library::set_lib_x86_64(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lib_x86_64();
  lib_x86_64_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Library.lib_x86_64)
}
inline void Library::set_lib_x86_64(const void* value, size_t size) {
  set_has_lib_x86_64();
  lib_x86_64_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Library.lib_x86_64)
}
inline ::std::string* Library::mutable_lib_x86_64() {
  set_has_lib_x86_64();
  // @@protoc_insertion_point(field_mutable:bmodel.Library.lib_x86_64)
  return lib_x86_64_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Library::release_lib_x86_64() {
  // @@protoc_insertion_point(field_release:bmodel.Library.lib_x86_64)
  if (!has_lib_x86_64()) {
    return NULL;
  }
  clear_has_lib_x86_64();
  return lib_x86_64_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Library::set_allocated_lib_x86_64(::std::string* lib_x86_64) {
  if (lib_x86_64 != NULL) {
    set_has_lib_x86_64();
  } else {
    clear_has_lib_x86_64();
  }
  lib_x86_64_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lib_x86_64);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Library.lib_x86_64)
}

// required bytes lib_armv8 = 3;
inline bool Library::has_lib_armv8() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Library::set_has_lib_armv8() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Library::clear_has_lib_armv8() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Library::clear_lib_armv8() {
  lib_armv8_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lib_armv8();
}
inline const ::std::string& Library::lib_armv8() const {
  // @@protoc_insertion_point(field_get:bmodel.Library.lib_armv8)
  return lib_armv8_.GetNoArena();
}
inline void Library::set_lib_armv8(const ::std::string& value) {
  set_has_lib_armv8();
  lib_armv8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bmodel.Library.lib_armv8)
}
#if LANG_CXX11
inline void Library::set_lib_armv8(::std::string&& value) {
  set_has_lib_armv8();
  lib_armv8_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Library.lib_armv8)
}
#endif
inline void Library::set_lib_armv8(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lib_armv8();
  lib_armv8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Library.lib_armv8)
}
inline void Library::set_lib_armv8(const void* value, size_t size) {
  set_has_lib_armv8();
  lib_armv8_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Library.lib_armv8)
}
inline ::std::string* Library::mutable_lib_armv8() {
  set_has_lib_armv8();
  // @@protoc_insertion_point(field_mutable:bmodel.Library.lib_armv8)
  return lib_armv8_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Library::release_lib_armv8() {
  // @@protoc_insertion_point(field_release:bmodel.Library.lib_armv8)
  if (!has_lib_armv8()) {
    return NULL;
  }
  clear_has_lib_armv8();
  return lib_armv8_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Library::set_allocated_lib_armv8(::std::string* lib_armv8) {
  if (lib_armv8 != NULL) {
    set_has_lib_armv8();
  } else {
    clear_has_lib_armv8();
  }
  lib_armv8_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lib_armv8);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Library.lib_armv8)
}

// -------------------------------------------------------------------

// Weight

// required uint64 weight_offset = 1;
inline bool Weight::has_weight_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Weight::set_has_weight_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Weight::clear_has_weight_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Weight::clear_weight_offset() {
  weight_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_weight_offset();
}
inline ::google::protobuf::uint64 Weight::weight_offset() const {
  // @@protoc_insertion_point(field_get:bmodel.Weight.weight_offset)
  return weight_offset_;
}
inline void Weight::set_weight_offset(::google::protobuf::uint64 value) {
  set_has_weight_offset();
  weight_offset_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Weight.weight_offset)
}

// required uint64 weight_length = 2;
inline bool Weight::has_weight_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Weight::set_has_weight_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Weight::clear_has_weight_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Weight::clear_weight_length() {
  weight_length_ = GOOGLE_ULONGLONG(0);
  clear_has_weight_length();
}
inline ::google::protobuf::uint64 Weight::weight_length() const {
  // @@protoc_insertion_point(field_get:bmodel.Weight.weight_length)
  return weight_length_;
}
inline void Weight::set_weight_length(::google::protobuf::uint64 value) {
  set_has_weight_length();
  weight_length_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Weight.weight_length)
}

// -------------------------------------------------------------------

// Model

// optional string type = 8 [default = "A"];
inline bool Model::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Model::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Model::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Model::clear_type() {
  type_.ClearToDefaultNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get());
  clear_has_type();
}
inline const ::std::string& Model::type() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.type)
  return type_.GetNoArena();
}
inline void Model::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get(), value);
  // @@protoc_insertion_point(field_set:bmodel.Model.type)
}
#if LANG_CXX11
inline void Model::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Model.type)
}
#endif
inline void Model::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Model.type)
}
inline void Model::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Model.type)
}
inline ::std::string* Model::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:bmodel.Model.type)
  return type_.MutableNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get());
}
inline ::std::string* Model::release_type() {
  // @@protoc_insertion_point(field_release:bmodel.Model.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get());
}
inline void Model::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_type_.get(), type);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Model.type)
}

// optional string version = 9 [default = "2.1"];
inline bool Model::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Model::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Model::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Model::clear_version() {
  version_.ClearToDefaultNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get());
  clear_has_version();
}
inline const ::std::string& Model::version() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.version)
  return version_.GetNoArena();
}
inline void Model::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get(), value);
  // @@protoc_insertion_point(field_set:bmodel.Model.version)
}
#if LANG_CXX11
inline void Model::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Model.version)
}
#endif
inline void Model::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Model.version)
}
inline void Model::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Model.version)
}
inline ::std::string* Model::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:bmodel.Model.version)
  return version_.MutableNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get());
}
inline ::std::string* Model::release_version() {
  // @@protoc_insertion_point(field_release:bmodel.Model.version)
  if (!has_version()) {
    return NULL;
  }
  clear_has_version();
  return version_.ReleaseNonDefaultNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get());
}
inline void Model::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::bmodel::Model::_i_give_permission_to_break_this_code_default_version_.get(), version);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Model.version)
}

// required string net_name = 1;
inline bool Model::has_net_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_net_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_net_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_net_name() {
  net_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_net_name();
}
inline const ::std::string& Model::net_name() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.net_name)
  return net_name_.GetNoArena();
}
inline void Model::set_net_name(const ::std::string& value) {
  set_has_net_name();
  net_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bmodel.Model.net_name)
}
#if LANG_CXX11
inline void Model::set_net_name(::std::string&& value) {
  set_has_net_name();
  net_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bmodel.Model.net_name)
}
#endif
inline void Model::set_net_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_net_name();
  net_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bmodel.Model.net_name)
}
inline void Model::set_net_name(const char* value, size_t size) {
  set_has_net_name();
  net_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bmodel.Model.net_name)
}
inline ::std::string* Model::mutable_net_name() {
  set_has_net_name();
  // @@protoc_insertion_point(field_mutable:bmodel.Model.net_name)
  return net_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Model::release_net_name() {
  // @@protoc_insertion_point(field_release:bmodel.Model.net_name)
  if (!has_net_name()) {
    return NULL;
  }
  clear_has_net_name();
  return net_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Model::set_allocated_net_name(::std::string* net_name) {
  if (net_name != NULL) {
    set_has_net_name();
  } else {
    clear_has_net_name();
  }
  net_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), net_name);
  // @@protoc_insertion_point(field_set_allocated:bmodel.Model.net_name)
}

// required uint32 chip = 2;
inline bool Model::has_chip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Model::set_has_chip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Model::clear_has_chip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Model::clear_chip() {
  chip_ = 0u;
  clear_has_chip();
}
inline ::google::protobuf::uint32 Model::chip() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.chip)
  return chip_;
}
inline void Model::set_chip(::google::protobuf::uint32 value) {
  set_has_chip();
  chip_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Model.chip)
}

// optional uint32 node_num = 3 [default = 1];
inline bool Model::has_node_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Model::set_has_node_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Model::clear_has_node_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Model::clear_node_num() {
  node_num_ = 1u;
  clear_has_node_num();
}
inline ::google::protobuf::uint32 Model::node_num() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.node_num)
  return node_num_;
}
inline void Model::set_node_num(::google::protobuf::uint32 value) {
  set_has_node_num();
  node_num_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Model.node_num)
}

// required uint32 fmt = 4;
inline bool Model::has_fmt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Model::set_has_fmt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Model::clear_has_fmt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Model::clear_fmt() {
  fmt_ = 0u;
  clear_has_fmt();
}
inline ::google::protobuf::uint32 Model::fmt() const {
  // @@protoc_insertion_point(field_get:bmodel.Model.fmt)
  return fmt_;
}
inline void Model::set_fmt(::google::protobuf::uint32 value) {
  set_has_fmt();
  fmt_ = value;
  // @@protoc_insertion_point(field_set:bmodel.Model.fmt)
}

// repeated .bmodel.Command command = 5;
inline int Model::command_size() const {
  return command_.size();
}
inline void Model::clear_command() {
  command_.Clear();
}
inline ::bmodel::Command* Model::mutable_command(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Model.command)
  return command_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Command >*
Model::mutable_command() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Model.command)
  return &command_;
}
inline const ::bmodel::Command& Model::command(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Model.command)
  return command_.Get(index);
}
inline ::bmodel::Command* Model::add_command() {
  // @@protoc_insertion_point(field_add:bmodel.Model.command)
  return command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Command >&
Model::command() const {
  // @@protoc_insertion_point(field_list:bmodel.Model.command)
  return command_;
}

// repeated bytes weight = 6;
inline int Model::weight_size() const {
  return weight_.size();
}
inline void Model::clear_weight() {
  weight_.Clear();
}
inline const ::std::string& Model::weight(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Model.weight)
  return weight_.Get(index);
}
inline ::std::string* Model::mutable_weight(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Model.weight)
  return weight_.Mutable(index);
}
inline void Model::set_weight(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:bmodel.Model.weight)
  weight_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Model::set_weight(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:bmodel.Model.weight)
  weight_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Model::set_weight(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  weight_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bmodel.Model.weight)
}
inline void Model::set_weight(int index, const void* value, size_t size) {
  weight_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bmodel.Model.weight)
}
inline ::std::string* Model::add_weight() {
  // @@protoc_insertion_point(field_add_mutable:bmodel.Model.weight)
  return weight_.Add();
}
inline void Model::add_weight(const ::std::string& value) {
  weight_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bmodel.Model.weight)
}
#if LANG_CXX11
inline void Model::add_weight(::std::string&& value) {
  weight_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bmodel.Model.weight)
}
#endif
inline void Model::add_weight(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  weight_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bmodel.Model.weight)
}
inline void Model::add_weight(const void* value, size_t size) {
  weight_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bmodel.Model.weight)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Model::weight() const {
  // @@protoc_insertion_point(field_list:bmodel.Model.weight)
  return weight_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Model::mutable_weight() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Model.weight)
  return &weight_;
}

// repeated .bmodel.Library library = 7;
inline int Model::library_size() const {
  return library_.size();
}
inline void Model::clear_library() {
  library_.Clear();
}
inline ::bmodel::Library* Model::mutable_library(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Model.library)
  return library_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Library >*
Model::mutable_library() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Model.library)
  return &library_;
}
inline const ::bmodel::Library& Model::library(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Model.library)
  return library_.Get(index);
}
inline ::bmodel::Library* Model::add_library() {
  // @@protoc_insertion_point(field_add:bmodel.Model.library)
  return library_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Library >&
Model::library() const {
  // @@protoc_insertion_point(field_list:bmodel.Model.library)
  return library_;
}

// repeated .bmodel.Weight weight_info = 10;
inline int Model::weight_info_size() const {
  return weight_info_.size();
}
inline void Model::clear_weight_info() {
  weight_info_.Clear();
}
inline ::bmodel::Weight* Model::mutable_weight_info(int index) {
  // @@protoc_insertion_point(field_mutable:bmodel.Model.weight_info)
  return weight_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bmodel::Weight >*
Model::mutable_weight_info() {
  // @@protoc_insertion_point(field_mutable_list:bmodel.Model.weight_info)
  return &weight_info_;
}
inline const ::bmodel::Weight& Model::weight_info(int index) const {
  // @@protoc_insertion_point(field_get:bmodel.Model.weight_info)
  return weight_info_.Get(index);
}
inline ::bmodel::Weight* Model::add_weight_info() {
  // @@protoc_insertion_point(field_add:bmodel.Model.weight_info)
  return weight_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bmodel::Weight >&
Model::weight_info() const {
  // @@protoc_insertion_point(field_list:bmodel.Model.weight_info)
  return weight_info_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bmodel

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_bmodel_2eproto
